"use client";

import type { ColumnDef, FilterFn, Row } from "@tanstack/react-table";
import { CopyIcon, ExternalLinkIcon, TrashIcon } from "lucide-react";
import { formatDateTime } from "@/lib/helpers/format-date";
import type { MeetingLog, Phase, Sprint } from "@/lib/types";
import { GenericRowActions, type ActionConfig } from "@/components/shared/table";

export type MeetingsTableRow = MeetingLog & {
	contextLabel: string;
};

const multiColumnFilterFn: FilterFn<MeetingsTableRow> = (
	row,
	_columnId,
	filterValue
) => {
	const searchTerm = (filterValue ?? "").toString().toLowerCase().trim();
	if (!searchTerm) return true;

	const uploader = row.original.uploader;
	const searchableRowContent = [
		row.original.title,
		row.original.contextLabel,
		uploader?.name,
		uploader?.email,
		row.getValue("scope") as string,
		formatDateTime(row.getValue("date") as string),
	]
		.filter(Boolean)
		.join(" ")
		.toLowerCase();

	return searchableRowContent.includes(searchTerm);
};

const scopeFilterFn: FilterFn<MeetingsTableRow> = (row, _columnId, filterValue) => {
	const selected = (filterValue ?? []) as string[];
	if (!selected.length) return true;

	const scope = row.original.sprintId ? "Sprint" : "Phase";
	return selected.includes(scope);
};

function buildContextLabel(log: MeetingLog, sprints: Sprint[], phases: Phase[]): string {
	if (log.sprintId) {
		const sprint = sprints.find((s) => s.id === log.sprintId);
		return sprint ? `Sprint ${sprint.number}` : "Sprint";
	}
	if (log.phaseId) {
		const phase = phases.find((p) => p.id === log.phaseId);
		return phase?.name ?? "Phase";
	}
	return "Unassigned";
}

type ColumnsContext = {
	phases: Phase[];
	sprints: Sprint[];
	onAction?: (actionId: string, row: MeetingsTableRow) => Promise<void>;
	loadingIds?: Set<string>;
};

export function createMeetingColumns(context: ColumnsContext): {
	columns: ColumnDef<MeetingsTableRow>[];
	toRows: (logs: MeetingLog[]) => MeetingsTableRow[];
} {
	const toRows = (logs: MeetingLog[]): MeetingsTableRow[] =>
		logs.map((log) => ({
			...log,
			contextLabel: buildContextLabel(log, context.sprints, context.phases),
		}));

	const columns: ColumnDef<MeetingsTableRow>[] = [
		{
			accessorKey: "title",
			size: 220,
			enableHiding: false,
			filterFn: multiColumnFilterFn,
			header: "Title",
			cell: ({ row }) => (
				<div className="font-medium max-w-md truncate">
					{row.getValue("title")}
				</div>
			),
		},
		{
			id: "scope",
			size: 120,
			accessorFn: (row) => (row.sprintId ? "Sprint" : row.phaseId ? "Phase" : "Unassigned"),
			filterFn: scopeFilterFn,
			header: "Scope",
			cell: ({ row }) => <div className="text-sm">{row.getValue("scope")}</div>,
		},
		{
			accessorKey: "contextLabel",
			size: 120,
			header: "Sprint or Phase",
			cell: ({ row }) => <div className="text-sm max-w-md truncate">{row.getValue("contextLabel")}</div>,
		},
		{
			accessorKey: "date",
			size: 180,
			header: "Date",
			cell: ({ row }) => <div className="text-sm">{formatDateTime(row.getValue("date"))}</div>,
		},
		{
			id: "uploader",
			size: 220,
			accessorFn: (row) => row.uploader?.name ?? "",
			header: "Uploaded by",
			cell: ({ row }) => {
				const uploader = row.original.uploader;
				if (!uploader) return <span className="text-muted-foreground text-sm">Unknown</span>;
				return (
					<div className="leading-tight">
						<div className="text-sm font-medium">{uploader.name}</div>
						<div className="text-muted-foreground text-xs">{uploader.email}</div>
					</div>
				);
			},
		},
		{
			id: "actions",
			size: 60,
			enableHiding: false,
			enableSorting: false,
			header: () => <span className="sr-only">Actions</span>,
			cell: ({ row }) => {
				const actions: ActionConfig[] = [
					{
						id: "view",
						label: "Open minutes",
						icon: ExternalLinkIcon,
					},
					{
						id: "copy",
						label: "Copy link",
						icon: CopyIcon,
					},
					{
						id: "delete",
						label: "Delete",
						icon: TrashIcon,
						variant: "destructive",
					},
				];

				return (
					<GenericRowActions
						actions={actions}
						isLoading={context.loadingIds?.has(row.original.id) ?? false}
						onAction={(actionId) => context.onAction?.(actionId, row.original)}
						row={row}
					/>
				);
			},
		},
	];

	return { columns, toRows };
}
